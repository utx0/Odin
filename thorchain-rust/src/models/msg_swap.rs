/*
 * Thornode API
 *
 * Thornode REST API.
 *
 * The version of the OpenAPI document: 1.119.0
 * Contact: devs@thorchain.org
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct MsgSwap {
    #[serde(rename = "tx")]
    pub tx: Box<crate::models::Tx>,
    /// the asset to be swapped to
    #[serde(rename = "target_asset")]
    pub target_asset: String,
    /// the destination address to receive the swap output
    #[serde(rename = "destination", skip_serializing_if = "Option::is_none")]
    pub destination: Option<String>,
    /// the minimum amount of output asset to receive (else cancelling and refunding the swap)
    #[serde(rename = "trade_target")]
    pub trade_target: String,
    /// the affiliate address which will receive any affiliate fee
    #[serde(rename = "affiliate_address", skip_serializing_if = "Option::is_none")]
    pub affiliate_address: Option<String>,
    /// the affiliate fee in basis points
    #[serde(rename = "affiliate_basis_points")]
    pub affiliate_basis_points: String,
    /// the signer (sender) of the transaction
    #[serde(rename = "signer", skip_serializing_if = "Option::is_none")]
    pub signer: Option<String>,
    /// the contract address if an aggregator is specified for a non-THORChain SwapOut
    #[serde(rename = "aggregator", skip_serializing_if = "Option::is_none")]
    pub aggregator: Option<String>,
    /// the desired output asset of the aggregator SwapOut
    #[serde(rename = "aggregator_target_address", skip_serializing_if = "Option::is_none")]
    pub aggregator_target_address: Option<String>,
    /// the minimum amount of SwapOut asset to receive (else cancelling the SwapOut and receiving THORChain's output)
    #[serde(rename = "aggregator_target_limit", skip_serializing_if = "Option::is_none")]
    pub aggregator_target_limit: Option<String>,
    /// 0 if a market order (immediately completed or refunded), 1 if a limit order (held until fulfillable)
    #[serde(rename = "order_type", skip_serializing_if = "Option::is_none")]
    pub order_type: Option<i64>,
    /// number of swaps to execute in a streaming swap
    #[serde(rename = "stream_quantity", skip_serializing_if = "Option::is_none")]
    pub stream_quantity: Option<i32>,
    /// the interval (in blocks) to execute the streaming swap
    #[serde(rename = "stream_interval", skip_serializing_if = "Option::is_none")]
    pub stream_interval: Option<i32>,
}

impl MsgSwap {
    pub fn new(tx: crate::models::Tx, target_asset: String, trade_target: String, affiliate_basis_points: String) -> MsgSwap {
        MsgSwap {
            tx: Box::new(tx),
            target_asset,
            destination: None,
            trade_target,
            affiliate_address: None,
            affiliate_basis_points,
            signer: None,
            aggregator: None,
            aggregator_target_address: None,
            aggregator_target_limit: None,
            order_type: None,
            stream_quantity: None,
            stream_interval: None,
        }
    }
}


