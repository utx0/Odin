/*
 * Thornode API
 *
 * Thornode REST API.
 *
 * The version of the OpenAPI document: 1.119.0
 * Contact: devs@thorchain.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`quoteloanclose`]
#[derive(Clone, Debug, Default)]
pub struct QuoteloancloseParams {
    /// optional block height, defaults to current tip
    pub height: Option<i64>,
    /// the asset used to repay the loan
    pub from_asset: Option<String>,
    /// the asset amount in 1e8 decimals
    pub amount: Option<i64>,
    /// the collateral asset of the loan
    pub to_asset: Option<String>,
    /// the owner of the loan collateral
    pub loan_owner: Option<String>,
    /// the minimum amount of the target asset to accept
    pub min_out: Option<String>
}

/// struct for passing parameters to the method [`quoteloanopen`]
#[derive(Clone, Debug, Default)]
pub struct QuoteloanopenParams {
    /// optional block height, defaults to current tip
    pub height: Option<i64>,
    /// the collateral asset
    pub from_asset: Option<String>,
    /// the collateral asset amount in 1e8 decimals
    pub amount: Option<i64>,
    /// the target asset to receive (loan denominated in TOR regardless)
    pub to_asset: Option<String>,
    /// the destination address, required to generate memo
    pub destination: Option<String>,
    /// the minimum amount of the target asset to accept
    pub min_out: Option<String>,
    /// the affiliate fee in basis points
    pub affiliate_bps: Option<i64>,
    /// the affiliate (address or thorname)
    pub affiliate: Option<String>
}

/// struct for passing parameters to the method [`quotesaverdeposit`]
#[derive(Clone, Debug, Default)]
pub struct QuotesaverdepositParams {
    /// optional block height, defaults to current tip
    pub height: Option<i64>,
    /// the asset to deposit
    pub asset: Option<String>,
    /// the source asset amount in 1e8 decimals
    pub amount: Option<i64>
}

/// struct for passing parameters to the method [`quotesaverwithdraw`]
#[derive(Clone, Debug, Default)]
pub struct QuotesaverwithdrawParams {
    /// optional block height, defaults to current tip
    pub height: Option<i64>,
    /// the asset to withdraw
    pub asset: Option<String>,
    /// the address for the position
    pub address: Option<String>,
    /// the basis points of the existing position to withdraw
    pub withdraw_bps: Option<i64>
}

/// struct for passing parameters to the method [`quoteswap`]
#[derive(Clone, Debug, Default)]
pub struct QuoteswapParams {
    /// optional block height, defaults to current tip
    pub height: Option<i64>,
    /// the source asset
    pub from_asset: Option<String>,
    /// the target asset
    pub to_asset: Option<String>,
    /// the source asset amount in 1e8 decimals
    pub amount: Option<i64>,
    /// the destination address, required to generate memo
    pub destination: Option<String>,
    /// the interval in which streaming swaps are swapped
    pub streaming_interval: Option<i64>,
    /// the quantity of swaps within a streaming swap
    pub streaming_quantity: Option<i64>,
    /// the from address, required if the from asset is a synth
    pub from_address: Option<String>,
    /// the maximum basis points from the current feeless swap price to set the limit in the generated memo
    pub tolerance_bps: Option<i64>,
    /// the affiliate fee in basis points
    pub affiliate_bps: Option<i64>,
    /// the affiliate (address or thorname)
    pub affiliate: Option<String>
}


/// struct for typed errors of method [`quoteloanclose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuoteloancloseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`quoteloanopen`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuoteloanopenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`quotesaverdeposit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuotesaverdepositError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`quotesaverwithdraw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuotesaverwithdrawError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`quoteswap`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuoteswapError {
    UnknownValue(serde_json::Value),
}


/// Provide a quote estimate for the provided loan close.
pub async fn quoteloanclose(configuration: &configuration::Configuration, params: QuoteloancloseParams) -> Result<crate::models::QuoteLoanCloseResponse, Error<QuoteloancloseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let from_asset = params.from_asset;
    let amount = params.amount;
    let to_asset = params.to_asset;
    let loan_owner = params.loan_owner;
    let min_out = params.min_out;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorchain/quote/loan/close", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = height {
        local_var_req_builder = local_var_req_builder.query(&[("height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_asset {
        local_var_req_builder = local_var_req_builder.query(&[("from_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount {
        local_var_req_builder = local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_asset {
        local_var_req_builder = local_var_req_builder.query(&[("to_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = loan_owner {
        local_var_req_builder = local_var_req_builder.query(&[("loan_owner", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_out {
        local_var_req_builder = local_var_req_builder.query(&[("min_out", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuoteloancloseError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide a quote estimate for the provided loan open.
pub async fn quoteloanopen(configuration: &configuration::Configuration, params: QuoteloanopenParams) -> Result<crate::models::QuoteLoanOpenResponse, Error<QuoteloanopenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let from_asset = params.from_asset;
    let amount = params.amount;
    let to_asset = params.to_asset;
    let destination = params.destination;
    let min_out = params.min_out;
    let affiliate_bps = params.affiliate_bps;
    let affiliate = params.affiliate;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorchain/quote/loan/open", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = height {
        local_var_req_builder = local_var_req_builder.query(&[("height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_asset {
        local_var_req_builder = local_var_req_builder.query(&[("from_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount {
        local_var_req_builder = local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_asset {
        local_var_req_builder = local_var_req_builder.query(&[("to_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination {
        local_var_req_builder = local_var_req_builder.query(&[("destination", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_out {
        local_var_req_builder = local_var_req_builder.query(&[("min_out", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_bps {
        local_var_req_builder = local_var_req_builder.query(&[("affiliate_bps", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate {
        local_var_req_builder = local_var_req_builder.query(&[("affiliate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuoteloanopenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide a quote estimate for the provided saver deposit.
pub async fn quotesaverdeposit(configuration: &configuration::Configuration, params: QuotesaverdepositParams) -> Result<crate::models::QuoteSaverDepositResponse, Error<QuotesaverdepositError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let asset = params.asset;
    let amount = params.amount;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorchain/quote/saver/deposit", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = height {
        local_var_req_builder = local_var_req_builder.query(&[("height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = asset {
        local_var_req_builder = local_var_req_builder.query(&[("asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount {
        local_var_req_builder = local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuotesaverdepositError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide a quote estimate for the provided saver withdraw.
pub async fn quotesaverwithdraw(configuration: &configuration::Configuration, params: QuotesaverwithdrawParams) -> Result<crate::models::QuoteSaverWithdrawResponse, Error<QuotesaverwithdrawError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let asset = params.asset;
    let address = params.address;
    let withdraw_bps = params.withdraw_bps;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorchain/quote/saver/withdraw", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = height {
        local_var_req_builder = local_var_req_builder.query(&[("height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = asset {
        local_var_req_builder = local_var_req_builder.query(&[("asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = withdraw_bps {
        local_var_req_builder = local_var_req_builder.query(&[("withdraw_bps", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuotesaverwithdrawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide a quote estimate for the provided swap.
pub async fn quoteswap(configuration: &configuration::Configuration, params: QuoteswapParams) -> Result<crate::models::QuoteSwapResponse, Error<QuoteswapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let height = params.height;
    let from_asset = params.from_asset;
    let to_asset = params.to_asset;
    let amount = params.amount;
    let destination = params.destination;
    let streaming_interval = params.streaming_interval;
    let streaming_quantity = params.streaming_quantity;
    let from_address = params.from_address;
    let tolerance_bps = params.tolerance_bps;
    let affiliate_bps = params.affiliate_bps;
    let affiliate = params.affiliate;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/thorchain/quote/swap", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = height {
        local_var_req_builder = local_var_req_builder.query(&[("height", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_asset {
        local_var_req_builder = local_var_req_builder.query(&[("from_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_asset {
        local_var_req_builder = local_var_req_builder.query(&[("to_asset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount {
        local_var_req_builder = local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination {
        local_var_req_builder = local_var_req_builder.query(&[("destination", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = streaming_interval {
        local_var_req_builder = local_var_req_builder.query(&[("streaming_interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = streaming_quantity {
        local_var_req_builder = local_var_req_builder.query(&[("streaming_quantity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_address {
        local_var_req_builder = local_var_req_builder.query(&[("from_address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tolerance_bps {
        local_var_req_builder = local_var_req_builder.query(&[("tolerance_bps", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate_bps {
        local_var_req_builder = local_var_req_builder.query(&[("affiliate_bps", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = affiliate {
        local_var_req_builder = local_var_req_builder.query(&[("affiliate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuoteswapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

